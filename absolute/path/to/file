package main

import (
	"log"
	"strconv"
	"file-service/config"
	"file-service/controllers"
	"file-service/database"
	"file-service/service"
	"time"

	"github.com/gin-gonic/gin"
)

func main() {
	// 加载配置
	if err := config.LoadConfig(); err != nil {
		log.Fatal("Failed to load config:", err)
	}

	// 初始化数据库
	database.InitDB()
	defer database.CloseDB()

	// 启动定时清理过期文件任务
	go startExpiredFileCleanupTask()

	// 创建Gin路由器
	router := gin.Default()

	// 设置静态文件服务
	router.Static("/", "./static")

	// 创建文件控制器
	fileController := controllers.NewFileController()

	// 定义路由
	router.POST("/upload/", fileController.UploadFiles)
	router.GET("/download/:fileName", fileController.DownloadFile)
	router.GET("/files/", fileController.GetFileList)
	router.POST("/delete/", fileController.DeleteFiles)

	// 启动服务器
	port := config.AppConfig.Server.Port
	log.Printf("Server starting on port %d", port)
	if err := router.Run(":" + strconv.Itoa(port)); err != nil {
		log.Fatal("Failed to start server:", err)
	}
}

// startExpiredFileCleanupTask 启动定时清理过期文件任务
func startExpiredFileCleanupTask() {
	// 每天凌晨2点执行清理任务
	for {
		now := time.Now()
		// 计算到下一个凌晨2点的时间
		next := time.Date(now.Year(), now.Month(), now.Day(), 2, 0, 0, 0, now.Location())
		if next.Before(now) {
			// 如果今天已经过了2点，则计算明天的2点
			next = next.Add(24 * time.Hour)
		}
		// 等待到下一个执行时间
		time.Sleep(next.Sub(now))
		
		// 执行清理任务
		fileService := &service.FileService{}
		fileService.CleanExpiredFiles()
		log.Println("Expired files cleanup completed")
	}
}

// DeleteFiles 删除文件
func (fc *FileController) DeleteFiles(c *gin.Context) {
	// 解析请求体中的ID列表
	var ids []uint64
	if err := c.ShouldBindJSON(&ids); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
		return
	}

	// 调用服务删除文件
	count, err := fc.fileService.DeleteFilesByIds(ids)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"message": fmt.Sprintf("delete files failed: %v", err),
			"count":   0,
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "delete files success",
		"count":   count,
	})
}

// DeleteFilesByIds 根据ID批量删除文件
func (fs *FileService) DeleteFilesByIds(ids []uint64) (int, error) {
	if len(ids) == 0 {
		return 0, nil
	}

	// 分批处理，每批500个
	batchSize := 500
	count := 0

	for i := 0; i < len(ids); i += batchSize {
		end := i + batchSize
		if end > len(ids) {
			end = len(ids)
		}

		batchIds := ids[i:end]

		// 批量查询有效文件
		var fileInfos []models.FileInfo
		if err := database.DB.Where("id IN (?) AND status = ?", batchIds, 0).Find(&fileInfos).Error; err != nil {
			return count, fmt.Errorf("failed to query files: %v", err)
		}

		var validIds []uint64

		// 删除物理文件并收集有效ID
		for _, fileInfo := range fileInfos {
			// 即使文件不存在，也要将ID加入有效ID列表以更新数据库状态
			if err := os.Remove(fileInfo.FilePath); err != nil && !os.IsNotExist(err) {
				// 记录错误但继续处理其他文件
				log.Printf("Failed to delete file %s: %v", fileInfo.FilePath, err)
			}
			validIds = append(validIds, fileInfo.ID)
		}

		// 批量更新数据库状态
		if len(validIds) > 0 {
			if err := database.DB.Table("fileInfo").Where("id IN (?)", validIds).Update("status", 1).Error; err != nil {
				return count, fmt.Errorf("failed to update file status: %v", err)
			}
			count += len(validIds)
		}
	}

	return count, nil
}